roundingError.py: firstly, do not use the python round function, because round(2.675,2) evaluates to 2.67 due to precision of floating numbers. Instead, we evaluate our fraction by modulo the numerator and the denominator. Let the modolo be M. Let the increment in fraction caused by adding one unit be C. We want to add multiple number of C to M so that the result is greater or equal to half of N+1. If M+C do not overflow N, we would always choose the largest M to add. Otherwise it is a bad idea to add C to M because the result wraps around and we are further aways from (N+1)/2. Thus I set a variable called sentinel, which equals to N-C. If M is smaller than sentinel, we are good. Otherwise, it is equivalent to have a staring offset at -(N-M) because we will wrap around when we add C.

transmutation.cpp: The first key observation is that suppose element A can be made of B and C, then if during any step A is required to produce lead and there are A left, it is always optimal to use A first rather than using B and C to make A. If we think we should use BC first and save A for now and used it in somewhere else later, suppose A is saved for now and used to make D later, it is at least equally good to use A first and later use BC to make D. And if later we are required to use B or C to produce lead, the B and C we saved earlier would be right away available. To find the maximum number of lead we can produce, we binary search on each possible lead quantity T. If T is more than the number of lead we have, we propagate the debt, through the formula to produce T, to its ingredients. Now, we know we have used up T so in later production, if T appear as intermediate element, we will have to obtain T through its ingredients. We update this information by updating all formula of other elements. If any other element contains T as its ingredient, now T would be replaced by T's ingredients through T's formula. After the update, T will never appear in any of the formula. 

roadSign.cpp: we can use binary search to obtain a S^2 log S solution, but divide and conquer only need S log S time complexity. 
