cryptopangram.py: Initially I thought it was a simple gcd between neighboring pairs, but then realized that neighboring values could be the same. Let us call these value pairs with same values S pairs. To determine values in S, we can find the closest neighboring pair with different values, and propagate towards S. There are two scenarios when we encouter an S pair: 1. If we have already solved a previous gcd, we can simply remember the previous gcd and propagating from front to end. 2. If the beginning values are all same, we put them in an array and store them. Once we encounter a neighboring pair with different values, we can work backwards and determine values for all the S pairs stored in the array. Note that the second scenario can only happen once. 

datBae-my.py: Before reading the official analysis, I implemented a solution based on binary search. The idea is for each unknown interval \[a,b), let mid=(a+b)/2. We will guess \[a,mid) to be zeros and \[mid,b) to be ones, i.e. our guess will be (mid-a) number of zeros followed by (b-mid) number of ones. We will then get a response from the judge (which corresponds to interval \[a,b)) which consists of U zeors and V ones. We will then be able to know that mid-a-U computers are broke in the interval \[a,mid), and b-mid-V computers are broke in the interval \[mid,b). To know which part of the response corresponds to interval \[a,b), we maintain a dictionary D. After we obtained the results of U and V, we store corresponding intervals in D with values of U and V.

datBae.py: The key observation is that the number of broken computers B<=15. Thus if we label each column we sent from 0 to 31 periodically, we will be able to know  the block number and block offset, by looking into the relationship between the labels of two consecutive columns L1 and L2. If L2>L1, they are in the same block. If L2<L1, we must have moved into another block.
