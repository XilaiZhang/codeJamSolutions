incrementalPancake.cpp: When calculating the bounds, we make sure that long long do not overflow. Also, at each stage, we ensure that L or R always have more than value E if we decide to subtract E from either of them. Key observation is the two stacks decrease alternatively as we remove pancakes from them.

securityUpdate.py: An assignment of Time or ranks will lead to an assignment of latency. We can come up with a sorted list of computers by ranks, and another sorted list of computers by time. We merge the two lists together to create a complete sorted  list of rank or T. 

wormholeOne.cpp: Initially I thought it was dfs but then I realized that the wormholes are bidirectional and the ball must go into the "first" hole in the direction. After making the key observation that we only care about holes on the same line (with the same slope and offset), I come up with an union & find approach that solves the problem. 

emacs++.cpp: This is an implementation that passes the first test set. We can view the overall topolgy as a tree and apply a lca-like approach. For each character C, I record the position of its parent (always a left bracket), the position of the matching character (if C is '(', the matching character is a ')', and vice versa), the number of children it has (only children that is in the next level are counted. grandchildren and below are not counted), the position of this character among its parent's children (for example, if its parent has 4 children "()()" and our character is the 3rd, we record 3). For each starting postion S and each ending position E, we find the minimal moves it takes for the current position to move to its parent position (recorded as leftCost), and to the matching character of its parent( recorded as rightCost). Both S and E stop moving up once they reach the LCA level. And on the lca level, let the bracket on the left be from position l1 to l2, and let the bracket on the right be from r1 to r2. If the two ancestors is the same interval (meaning that E is a child of S, or S is a child of E. In code it is l1==r1 and l2==r2), we calculate the cost as min(l1+r1,l2+r2). If l1l2 and r1r2 are two different ranges, there are two scenarios: 1. we either move from l2 to r1. 2. or move from l1 to its parent, to the matching position, and then to r2. 
