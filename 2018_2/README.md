gracefulChainsaw.cpp: We first come up with knapsack dp of R*\B combinations with max Values of R and B, the complexity of which is R^2*\B^2. We then realize that R<=500 and B<=500. Now, in the most extreme cases, if R=0 and B=500, we would take a prefix of the pairs of (0,0),(0,1),(0,2)...(0,50); Similarly, if R=500 and B=0, we would take a prefix of the pairs of (0,0),(1,0),(2,0)...(50,0). Other cases where 0<=R<=500 and 0<=B<=500, We would take some mixture of pairs of (i,j) and we know that both i and j are smaller than 50! Thus, we can replace the R*\B dimension of our original knapsack dp with 50*\50 value pairs. What's more, we can precompute the dp arrays for all test cases, then for each test case, we simply retrieve the value from dp arrays. 

costumeChange.cpp: we use biparite matching to find the maximum number of people wearing costume X and do not share a row or column with other people. We match the row number with a unique column number, since any two people should not share a row or a column.
