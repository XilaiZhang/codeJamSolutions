gracefulChainsaw.cpp: We first come up with knapsack dp of R*\B combinations with max Values of R and B, the complexity of which is R^2*\B^2. We then realize that R<=500 and B<=500. Now, in the most extreme cases, if R=0 and B=500, we would take a prefix of the pairs of (0,0),(0,1),(0,2)...(0,50); Similarly, if R=500 and B=0, we would take a prefix of the pairs of (0,0),(1,0),(2,0)...(50,0). Other cases where 0<=R<=500 and 0<=B<=500, We would take some mixture of pairs of (i,j) and we know that both i and j are smaller than 50! Thus, we can replace the R*\B dimension of our original knapsack dp with 50*\50 value pairs. What's more, we can precompute the dp arrays for all test cases, then for each test case, we simply retrieve the value from dp arrays. 

costumeChange.cpp: we use biparite matching to find the maximum number of people wearing costume X and do not share a row or column with other people. We match the row number with a unique column number, since any two people should not share a row or a column.

gridception.cpp: We make the observation that an infinitely large dream is composed of infinitely large blocks of Bs and Ws. For each pattern, it can only span across 1,2,3 or 4 of the infinitely large blocks. We make sure that the topology of such 4 blocks exist by recording the topology of every 2 by 2 square in the original dream. (we also want to record the 1 by 2 topologies in case the center of quadrant is on the edge) After we make sure the toplogies exist, we iterate through potential centers of quadrants and calculate the largest connected component in the original dream through dfs.
