pancakeFlipper.py: Let us model each flip as an event. A single flip from pancake i to pancake i+K-1 is equivalent to, one flip on K pancakes from pancake i to pancake i+K-1 and 2 flips on every pancake after pancake i+K. Iterating from left to right, whenver we see a pancake is facing down and the equivalent flip count is even, or a pancake is facing up but flip count is odd, we do one flip. Runtime is O(N).

tidyNumbers.py: iterate from end to start. if number\[i-1] is greater than number\[i], we decrease number\[i-1] by 1 and make every number after number\[i] digit 9.

bathroomStalls.cpp: We are interested in the length of consecutive empty stalls, let us call these segments of empty stalls S. Suppose we have two stall segments S1 and S2 such that S2=S1+1, with S1 being even and S2 being odd, let S1=2*\X and S2=2*\X+1. Then S1 will generate stall segments X-1 and X, and S2 will generate stall segments X and X. Since X-1 and X are two stalls with one being even and the other being odd, and X=(X-1)+1, we can rename X-1 to be the new S1 and X be the new S2 and repeat the pattern. Note that 2*\X is always greater than X if X is at least 1. So we are safe to proceed from bigger values to smaller values. If we have two stalls S1==S2, we can consider the branch of S1 because the splitting pattern of S2 split will be the exact same as the splitting pattern of S1. One pitfall to consider is the precision of devision. We will avoid division to preserve the precision.

fashionShow.cpp: We can rephrase the question as "x cannot share the same row or column with another x, + cannot share the same diagnol or antidiagnol with another +. It is easy to arrange the x, we will always end up with N number of x in the grid. To arrange +, we apply biparite matching technique. We want a biparite matching from the diagnols to the antidiagnols. After we obtain maximum arrangement of + and x, we merge the two arrangements. If in a certain cell both + and x are arranged, we arrange 'o' instead. 
