countingSheep.py: Initially I bounded the multiple by 10^6. In fact we can bound the multiple by 100, because the smallest exponential of 10 that is greater than N, when added by N continuously, will always generate digits 1 to 9.  

revengeOfPancakes.py: Let M denote the number of continuous segments in segment S (top S elements) of the stack. Taking the inverse of S will not change the topology and thus M will not change. Taking the complement of S will not change the topology of continuous segments arrangements, and thus M will still not change. What could be affected is the segment S2 that comes after S. S and S2 could have segment merged together so that the overall M of the stack is reduced. But this number can at most be reduced by 1. With this observation we can set the lower bound of flip to be M2-1, where M2 is the number of continuous segments of the entire stack. Since our greedy solution takes exactly M2-1 steps to reduce the number of continuous segments to 1, we know M2-1 is achievable. The extra 1 flip comes from the fact we might need to flip the entire "-----" array into "+++++" in the end.

coinJam.py: I constructed my number this way. For base in 3,5,7,9, as long as our number have even number of 1s, we will get a factor of 2. For base 2,4,6,8,10, we will get factor 3,5,7,9,11 respectively, as long as we have equal number of 1s in even and odd positions. Thus, I paired the digits of the number into group of 2s, and assigned them to both 0 or both 1 to construct valid answers.
