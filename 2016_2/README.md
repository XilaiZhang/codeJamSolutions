ratherPerplexingShowdown.py: If we reverse thinking, we can build the entire tree from the end result. To maintain an alphabetically correct order, we can use a recursion function F to return a sorted string at each node. As we iterate from the leaf of tree to the root of the tree. At each step, let node A have two children B and C. then F(A)=F(B)+F(C) if B<C and F(A)=F(C)+F(B) otherwise. The answer is F(root).

redTape.cpp: We first sort the probability inputs. Note that the max probability is reached when we pick segments from both ends. i.e. for N people that are sorted, we would like to pick i people from the left, and K-i people from the right. For K choices of i, we iterate through each i. For each i, we build knapsack-like dp table to find the probablity of K/2 people voting yes. 

gardener of seville: The solution is already provided in official analysis.

freeformFactory.cpp: We would like to find the connected components of complete biparite graphs such that the total number of edges are smallest. To do so, we first note that there are a few topologies of connected components such that the added sum is within the bound of 25. ((1,0),(0,1),(1,1),(1,2),(2,1).....) For each of these topologies, I documented its quantity in a vector Q. For example, an empty graph with 25 nodes would have Q={25,25}, because it has 25 topology of (0,1) and 25 topology of (1,0). A combined struct of topologies and Q would allow us to store a specific formation in an unordered_map M. (I used customized hashing) Let the topology be an interger P which documents whether each topology is selected, and let Q be the quantity vector of each topology. Let struct S be the hashed key for P and Q. Let N be the connected component group that we currently formed with the given S. If we have a complete biparte graph C of size N and an incomplete biparite graph C1, and we are considering adding an component E. If C1 (note that C1 could be empty) and E form a complete biparite graph, then it is always ideal to do so, because a valid answer is always obtained in the process of continuously adding components to non-complete biparite graphs. When we add the componenet, we update the value of N if E and C1 form new complete bipartie graph. The entry in unordered_map M, M\[S]\[N] tells us the minimum total edges in the complete biparite graph of size N, and S is the topology. From each M\[S]\[N], we can try to add an component and forward dp. 
